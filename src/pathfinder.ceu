data PathNode with
    var int x;
    var int y;
end

code/await Pathfinder (var int fromX, var int fromY, var int toX, var int toY) 
    -> (vector[] PathNode path = [], event (int, int, int, int) do_retarget) 
        -> FOREVER do
    code/tight ProcessPath (void) -> void do
        outer.path = [];

        var PathNode pathFrom;
        pathFrom = val PathNode(outer.fromX, outer.fromY); // as _PathNode;
        var PathNode pathTo;
        pathTo = val PathNode(outer.toX, outer.toY); // as _PathNode;

        var _ASPath aspath;
        aspath = _ASPathCreate({&PathNodeSource}, {NULL}, &&pathFrom as _PathNode&&, &&pathTo as _PathNode&&);
        var usize path_size;
        path_size = _ASPathGetCount(aspath);
        
        if (path_size > 0) then
            var usize i;
            loop i in [0 -> path_size[ do
                var _PathNode&& pathNode;
                pathNode = _ASPathGetNode(aspath, i);
                var PathNode newNode;
                newNode = val PathNode(pathNode:x, pathNode:y); //regular typecast gets assertion errors
                //_printf("I am at node (%d, %d)\n", pathNode:x, pathNode:y);
                outer.path = outer.path .. [newNode];
            end
        end 
    end

    call ProcessPath();

    loop do
        (fromX, fromY, toX, toY) = await do_retarget;
        call ProcessPath();
    end
end